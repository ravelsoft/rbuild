{ dirname, join, resolve, existsSync, basename } = require \path
{ readFile } = require \fs

/**
 *  @class BundleFile
 *
 *  Handles dependencies checking and its own compilation.
 */
class BundleFile
    last_id = 0
    cached = {}
    body_re = //\brequire\s*\(\s*(
                    "(\\\"|[^"])*"    |     # double quoted string
                    '(\\\'|[^'])*'          # single quoted
                )\s*\)//g

    @get = function (path, extensions)
        return cached[path] if cached[path]

        return cached[path] = new BundleFile path, extensions

    (@path, @extensions) ->
        @compile_fn = null
        @error = false
        @body = null
        @deps = []
        @recompile = true

        @name = "#{basename @path}-#{last_id}"
        last_id := last_id + 1

    /**
     *  Compiles the module, and parse its contents, triggering the calling of 
     *
     *  @param cbk The callback for when we're done.
     *
     *  @returns An empty string if error, the body of the function otherwise.
     */
    getBody: function (cbk)
        if not @recompile
            cbk null, @body
            return

        @recompile = false

        if not @compile_fn?
            for ext, fn in @extensions
                realpath = "#{@path}.#ext"
                if existsSync realpath
                    @realpath = realpath
                    @compile_fn = fn
                    break

        if not @realpath
            cbk new Error "The file #{@path} either doesn't exist or doesn't have a valid module handler"

        (err, body) <~ readFile @realpath, \utf-8
        if err
            @error = true
            cbk err, null
            return

        if @verbose
            console.log "Compiling #{realpath}"

        @body = @compile_fn body
        @error = false
        @deps = []

        @body.replace body_re, (str) ~>
            mod_name = str.replace /.*require\s*\(\s*["']/, ''
                .replace /['"]\s*\)$/, ''

            dep_path = resolve (dirname @path), mod_name
            f = BundleFile.get dep_path, @extensions
            @deps.push f

            return "require('#{f.name}')"

        cbk null, @body


/**
 *  @class Bundler
 *
 *  A bundling class.
 */
class Bundler
    last_id = 0
    cached = {}

    /**
     *  @constructor
     */
    ({ extensions, files }) ->

        if typeof files is \string
            files = [files]

        files = (resolve "#{process.cwd!}/", f for f of files)

        @files = files
        @entry = @files.0

        @extensions =
            js: (str) -> str

        for ext, fn in extensions
            ((ext, fn) ~>
                @addExtension ext, (data, path) ->
                    try
                        fn data, path
                    catch e
                        console.log "!! #path: #e"
            )(ext, fn)

    /**
     *  Add an extension.
     *
     *  @param ext The extension
     *  @param cbk The callback that will handle its compilation.
     */
    addExtension: function (ext, cbk)
        @extensions[ext] = cbk

    /**
     *  Resolve a module's path from another.
     *
     *  First, compute the path difference between the two paths,
     *  then look for a file with all the registered extensions.
     *
     *  There is no promise on the order with which the extensions
     *  are looked for.
     *
     *  Once the file is found, it is read and tranformed according
     *  to its extension handler.
     *
     *  @param base The module where the resolving request's been
     *      made.
     *  @param path The path of the module.
     *  @param callback The callback to execute once we're done with
     *      the file. (error, contents)
     */
    processModules: function (path, callback)
        file = BundleFile.get path, @extensions

        if not file.recompile
            callback null
            return

        (err) <~ file.getBody!

        if not file.error
            if file.deps.length is 0
                callback err

            loaded = 0
            for f of file.deps
                (err) <~ @processModules f.path
                loaded := loaded + 1
                if loaded is file.deps.length
                    callback err
            
    /**
     *
     */
    bundleModule: function (module_name, module_contents)
        return """
            __modules_fn['#module_name'] = function (module) {
                __current_module = '#module_name';
                exports = module.exports;
                #module_contents
                return exports;
            };

            __modules['#module_name'] = null;
        """
    
    /**
     *
     */
    bundle: function
        @error = false

        processed = 0

        for f of @files
            <~ @processModules f
            processed := processed + 1
            if processed is @files.length
                console.log "next !"


        return
        # Fake variable
        __current_module = null

        /**
         *
         */
        function dirname (path)
            return path.replace /\\/g, '/'
                .replace /\/[^\/]*\/?$/, ''

        /**
         *
         */
        function resolve (path)
            curdir = dirname __current_module

        /**
         *
         */
        function require (path)
            path = resolve path

            if __modules[path] is null
                current_bak = __current_module
                module = exports: {}, id: path
                res = null

                __modules[path] = module
                res = __modules_fn[path] module
                __current_module := current_bak
                return res
            else
                return __modules[path].exports

        res = """
            var __modules_fn = {};
            var __modules = {};
            var __current_module = null;

            #{dirname.toString!}
            #{resolve.toString!}
            #{require.toString!}
        """

        return res

exports import { Bundler }
